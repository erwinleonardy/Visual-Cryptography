{% include "header.html" %}

<style>
#loader {
  top: -100% !important;
  left: 100% !important;
  margin: -250px 0 0 -75px !important;
}
</style>

<!-- Nav Bar -->
{%  with username=username, user_type = user_type, active_page="learning"%}
  {% include "navbar.html" %}
{% endwith %}

<!-- Content -->
<div class="jumbotron">
  <!-- Header -->
  <div class="container">

    <div class="row">
      <div class="col">
        <h1 class="display-4">Learning Tool</h1>
      </div>
    </div>

    <div class="row">
      <div class="col">
        <p class="lead">Use this panel to learn more about Visual Cryptography!</p>
        <hr class="my-4">
      </div>
    </div>
  </div>

  <!-- Form -->
  <form id="verify" method="post" enctype="multipart/form-data" onsubmit="return false;">
    <div class="container">

      <h5>What is Visual Cryptography?</h5>
      <p class="lead">Visual Cryptography is a technique that allows information (images, text, diagrams..) to be encrypted using an encoding system that can be decrypted by the eyes. No computer is required to decode.</p>

      <h5>What is Visual Steganography?</h5>
      <p class="lead">Steganography is a technique to conceal text, images, videos in a seemingly innocuous file. It makes use of unused pixels in regular computer files in order to hide another hidden text or image.</p>

      <h5>Demonstration</h5>
      <p class="lead">Don't take our words at face value! Try it out yourself! <b>Slide to the right</b> to see what happens!</p>

      <!-- Canvas -->
      <canvas id="intro" width="1110" height="330" style="background-color:white; margin-bottom:30px";>Your browser doesn't support the HTML5 Canvas, please consifer updating or changing your browser for a better experience.</canvas>
      
      <!-- Loader -->
      <div class="row">
        <div class="col-xs-6 col-sm-12 col-md-12 col-lg-6">
          <div id="loader"></div>
        </div>
      </div>

      <h5>Why Visual Steganography (Visual Cryptography + Steganography)?</h5>
      <p class="lead">As opposed to other forms of cryptography, visual cryptography requires the participation of the user. Decryption of the shares provide information that is only perceived visually, thus deterring automated attacks. It is akin to One Time Pad (OTP) that provides perfect secrecy, this is due to the incomplete information the attacker has to break the cipher. The Steganography technique we used allows us to make the secret less obvious and hence enhance the overall security even further.</p>

      <h5>How does it work?</h5>
      <p class="lead">This awesome technique should be attributed to two of the great Mathematicians: <b>Moni Naor</b> and <b>Adi Shamir</b>. They came out with a technique that requires the share of both parties to exists in order to decrypt the image.</p>
      <table class="table table-borderless">
        <tr width="100%">
          <td><img src="{{ url_for('static', filename='img/learning/left.png') }}" alt="left"></td>
          <td width="30%" class="align-middle">The basis of this technique is that it would overlay two semi-transparent layers on top of each other.</td>
          <td><img src="{{ url_for('static', filename='img/learning/right.png') }}" alt="right"></td>
        </tr>

        <tr width="100%">
          <td colspan="3" style="padding-left:80; padding-right:80px">Overlaying (mathematically equivalent to Binary OR operation) both of the shares creates addition interference to the light passing through it.</td>
        </tr>

        <tr width="100%">
          <td colspan="3"><img src="{{ url_for('static', filename='img/learning/merge.png') }}" alt="merged"></td>
        </tr>

        <tr width="100%">
          <td colspan="3" style="padding-left:80; padding-right:80px">When both of the shares are properly overlayed on top of each other, it will divulge the secret image as shown below.</td>
        </tr>

        <tr width="100%">
          <td colspan="3"><img src="{{ url_for('static', filename='img/learning/result.png') }}" alt="result"></td>
        </tr>
      </table>
      
      <h5>How does Visual Steganography work?</h5>
      <p class="lead">With this technique, we are going to sub-divide each pixel into (2x2) subpixels; these pixels are randomly generated and it has to conform to the following rules: when both of the images are overlayed, we can represent the <b>black pixels with 4 black sub-pixels</b> and <b>white with 3 black sub-pixels.</b></p>

      <table class="table table-striped">
        <tr>
          <td colspan="4">Black</td>
          <td colspan="4">White</td>
        </tr>
        <tr>
          <td colspan="4"><img src="{{ url_for('static', filename='img/learning/pattern/pat8.png') }}" alt="black"></td>
          <td colspan="4"><img src="{{ url_for('static', filename='img/learning/pattern/pat9.png') }}" alt="white"></td>
        </tr>

        <tr>
          <td colspan="8">After Expansion</td>
        </tr>
        <tr>
          <td colspan="4"><img src="{{ url_for('static', filename='img/learning/pattern/pat8-opaque.png') }}" alt="4black"></td>
          <td colspan="4"><img src="{{ url_for('static', filename='img/learning/pattern/pat7-opaque.png') }}" alt="3black"></td>
        </tr>

        <tr>
          <td>B1B2</td>
          <td>B1W2</td>
          <td>W1B2</td>
          <td>W1W2</td>
          <td>B1B2</td>
          <td>B1W2</td>
          <td>W1B2</td>
          <td>W1W2</td>
        </tr>
        <tr>
          <!-- Black -->
          <td>
            <canvas id="B1B2_Black" width="100%" height="330" style="background-color:white;";>Your browser doesn't support the HTML5 Canvas, please consifer updating or changing your browser for a better experience.</canvas>
          </td>
          <td>
            <canvas id="B1W2_Black" width="100%" height="330" style="background-color:white;";>Your browser doesn't support the HTML5 Canvas, please consifer updating or changing your browser for a better experience.</canvas>
          </td>
          <td>
            <canvas id="W1B2_Black" width="100%" height="330" style="background-color:white;";>Your browser doesn't support the HTML5 Canvas, please consifer updating or changing your browser for a better experience.</canvas>
          </td>
          <td>
            <canvas id="W1W2_Black" width="100%" height="330" style="background-color:white;";>Your browser doesn't support the HTML5 Canvas, please consifer updating or changing your browser for a better experience.</canvas>
          </td>

          <!-- White -->
          <td>
            <canvas id="B1B2_White" width="100%" height="330" style="background-color:white;";>Your browser doesn't support the HTML5 Canvas, please consifer updating or changing your browser for a better experience.</canvas>
          </td>
          <td>
            <canvas id="B1W2_White" width="100%" height="330" style="background-color:white;";>Your browser doesn't support the HTML5 Canvas, please consifer updating or changing your browser for a better experience.</canvas>
          </td>
          <td>
            <canvas id="W1B2_White" width="100%" height="330" style="background-color:white;";>Your browser doesn't support the HTML5 Canvas, please consifer updating or changing your browser for a better experience.</canvas>
          </td>
          <td>
            <canvas id="W1W2_White" width="100%" height="330" style="background-color:white;";>Your browser doesn't support the HTML5 Canvas, please consifer updating or changing your browser for a better experience.</canvas>
          </td>
        </tr>

        <tr>
          <td colspan="8">TRY IT OUT: Slide to the bottom to see what happens upon overlaying the two shares!</td>
        </tr>
      </table>
    </div>
  </form>
  
</div>

<div class="row">
  <div class="col-xs-6 col-sm-12 col-md-12 col-lg-6">
    <div id="loader"></div>
  </div>
</div> 

<script>
  document.getElementById("loader").style.display = "block";

  var three_black_1 = new Image();
  var three_black_2 = new Image();
  var three_black_3 = new Image();
  var two_black_1 = new Image();
  var two_black_2 = new Image();
  var two_black_3 = new Image();
  var three_black_4 = new Image();
  
  var bankShare = new Image();
  var clientShare = new Image();
  var reconShare = new Image();

  three_black_1.src = "https://raw.githubusercontent.com/erwinleonardy/VSignIt/master/img/public/pattern/Pat5.png";
  three_black_2.src = "https://raw.githubusercontent.com/erwinleonardy/VSignIt/master/img/public/pattern/Pat4.png";
  three_black_3.src = "https://raw.githubusercontent.com/erwinleonardy/VSignIt/master/img/public/pattern/Pat6.png";
  three_black_4.src = "https://raw.githubusercontent.com/erwinleonardy/VSignIt/master/img/public/pattern/Pat7.png";
  two_black_1.src = "https://raw.githubusercontent.com/erwinleonardy/VSignIt/master/img/public/pattern/Pat3.png";
  two_black_2.src = "https://raw.githubusercontent.com/erwinleonardy/VSignIt/master/img/public/pattern/Pat1.png";
  two_black_3.src = "https://raw.githubusercontent.com/erwinleonardy/VSignIt/master/img/public/pattern/Pat2.png";
  
  bankShare.src = "https://raw.githubusercontent.com/erwinleonardy/VSignIt/master/img/public/bank_share.png";
  clientShare.src = "https://raw.githubusercontent.com/erwinleonardy/VSignIt/master/img/public/client_share.png";
  reconShare.src = "https://raw.githubusercontent.com/erwinleonardy/VSignIt/master/img/public/recon_share.png";

  var maxY = B1W2_Black.height-100;
  var minY = 10;

  // define the centre point of the canvas
  cX = Math.floor(B1W2_Black.width / 2);
  cY = Math.floor(B1W2_Black.height / 2);

  // try to draw the cheque canvas
  function tryToDrawRecon()
  {
    // loads the cheque animation from the database
    var maxX = intro.width-315;
    var minX = 15;
    // ctx.drawImage(clientShare, 0, 0, 300, 300);

    // Get a "handle" on the canvas to work with
    theCanvas = document.getElementById("intro");

    // define the centre point of the canvas
    cX = Math.floor(theCanvas.width / 2);
    cY = Math.floor(theCanvas.height / 2);

    // Get a "context"
    ctx= theCanvas.getContext("2d");

    // draw the initial image
    ctx.drawImage(bankShare, 15, 15, 300, 300);
    ctx.drawImage(clientShare, maxX, 15, 300, 300);
    ctx.globalAlpha = 1.0;

    // Get the position of the mouse relative to the canvas
    function getMousePos(canvasDom, mouseEvent) {
      var rect = canvasDom.getBoundingClientRect();
      return {
        x: mouseEvent.clientX - rect.left,
        y: mouseEvent.clientY - rect.top
      };
    }

    // Here we get mouse coordinates and translate to a value
    // Good old basic algebra from school
    // Apparently the convention is to start at 0 degrees on the right and go backwards
    // - someone should have told that to clock-makers
    theCanvas.addEventListener("mousemove", function(e) {
      var m = getMousePos(theCanvas, e);
      if (m.x < cX) {
        if (m.y < cY) pos = 180 + Math.floor(Math.atan((m.y - cY) / (cX - m.x)) * (180 / Math.PI));
        else pos = 180 + -Math.floor(Math.atan((m.y - cY) / (m.x - cX)) * (180 / Math.PI));
      } else {
        if (m.y < cY) pos = - Math.floor(Math.atan((cY - m.y) / (cX - m.x)) * (180 / Math.PI)) ;
        else pos = 360 + Math.floor(Math.atan((cY - m.y) / (m.x - cX)) * (180 / Math.PI));
      }

      // print the result
      ctx.clearRect(0, 0, intro.width, intro.height);
    
      // replace image when it is perfectly overlayed
      // and prevent pictures from going out of canvas
      if (m.x >= maxX)
      {
        m.x = maxX;
        ctx.drawImage(reconShare, maxX, 15, 300, 300);
        return;
      }
      else if (m.x < minX)
        m.x = minX;

      ctx.drawImage(bankShare, 0+m.x, 15, 300, 300);
      ctx.drawImage(clientShare, maxX, 15, 300, 300);
    }, false);
  }

  // draw the 8 different permutations to generate black/white share
  function tryToDrawShares()
  {
    /*
    * B1W2_Black
    */
    // Get a "handle" on the canvas to work with
    B1B2_Black_Canvas = document.getElementById("B1B2_Black"); 
    
    // Get a "context"
    ctx2= B1B2_Black_Canvas.getContext("2d");

    // draw the initial image
    ctx2.drawImage(three_black_1, 0, 0, 100, 100);
    ctx2.drawImage(three_black_2, 0, maxY, 100, 100);
    ctx2.globalAlpha = 1.0;

    // Get the position of the mouse relative to the canvas
    function getMousePos(canvasDom, mouseEvent) {
      var rect = canvasDom.getBoundingClientRect();
      return {
        x: mouseEvent.clientX - rect.left,
        y: mouseEvent.clientY - rect.top
      };
    }

    // add mouse move listener to this canvas
    B1B2_Black_Canvas.addEventListener("mousemove", function(e) {
      var m = getMousePos(B1B2_Black_Canvas, e);
      if (m.x < cX) {
        if (m.y < cY) pos = 180 + Math.floor(Math.atan((m.y - cY) / (cX - m.x)) * (180 / Math.PI));
        else pos = 180 + -Math.floor(Math.atan((m.y - cY) / (m.x - cX)) * (180 / Math.PI));
      } else {
        if (m.y < cY) pos = - Math.floor(Math.atan((cY - m.y) / (cX - m.x)) * (180 / Math.PI)) ;
        else pos = 360 + Math.floor(Math.atan((cY - m.y) / (m.x - cX)) * (180 / Math.PI));
      }

      // print the result
      ctx2.clearRect(0, 0, B1B2_Black_Canvas.width, B1B2_Black_Canvas.height);
    
      // prevent pictures from going out of canvas
      if (m.y >= maxY)
        m.y = maxY;
      else if (m.y < minY)
        m.y = 0;

      ctx2.drawImage(three_black_1, 0, 0+m.y, 100, 100);
      ctx2.drawImage(three_black_2, 0, maxY, 100, 100);
    }, false); // end of B1B2_Black_Canvas.addEventListener("mousemove", function(e){...});

    /*
    * B1W2_Black
    */

    // Get a "handle" on the canvas to work with
    B1W2_Black_Canvas = document.getElementById("B1W2_Black");
      
    // Get a "context"
    ctx3= B1W2_Black_Canvas.getContext("2d");

    // draw the initial image
    ctx3.drawImage(three_black_1, 0, 0, 100, 100);
    ctx3.drawImage(two_black_1, 0, maxY, 100, 100);
    ctx3.globalAlpha = 1.0;

    // Get the position of the mouse relative to the canvas
    function getMousePos(canvasDom, mouseEvent) {
      var rect = canvasDom.getBoundingClientRect();
      return {
        x: mouseEvent.clientX - rect.left,
        y: mouseEvent.clientY - rect.top
      };
    }

    // add mouse move listener to this canvas
    B1W2_Black_Canvas.addEventListener("mousemove", function(e) {
      var m = getMousePos(B1W2_Black_Canvas, e);
      if (m.x < cX) {
        if (m.y < cY) pos = 180 + Math.floor(Math.atan((m.y - cY) / (cX - m.x)) * (180 / Math.PI));
        else pos = 180 + -Math.floor(Math.atan((m.y - cY) / (m.x - cX)) * (180 / Math.PI));
      } else {
        if (m.y < cY) pos = - Math.floor(Math.atan((cY - m.y) / (cX - m.x)) * (180 / Math.PI)) ;
        else pos = 360 + Math.floor(Math.atan((cY - m.y) / (m.x - cX)) * (180 / Math.PI));
      }

      // print the result
      ctx3.clearRect(0, 0, B1W2_Black_Canvas.width, B1W2_Black_Canvas.height);
    
      // prevent pictures from going out of canvas
      if (m.y >= maxY)
        m.y = maxY;
      else if (m.y < minY)
        m.y = 0;

      ctx3.drawImage(three_black_1, 0, 0+m.y, 100, 100);
      ctx3.drawImage(two_black_1, 0, maxY, 100, 100);
    }, false); // end of B1W2_Black_Canvas.addEventListener("mousemove", function(e){...});

    /*
    * W1B2_Black
    */

    // Get a "handle" on the canvas to work with
    W1B2_Black_Canvas = document.getElementById("W1B2_Black");
      
    // Get a "context"
    ctx4= W1B2_Black_Canvas.getContext("2d");

    // draw the initial image
    ctx4.drawImage(two_black_2, 0, 0, 100, 100);
    ctx4.drawImage(three_black_3, 0, maxY, 100, 100);
    ctx4.globalAlpha = 1.0;

    // Get the position of the mouse relative to the canvas
    function getMousePos(canvasDom, mouseEvent) {
      var rect = canvasDom.getBoundingClientRect();
      return {
        x: mouseEvent.clientX - rect.left,
        y: mouseEvent.clientY - rect.top
      };
    }

    // add mouse move listener to this canvas
    W1B2_Black_Canvas.addEventListener("mousemove", function(e) {
      var m = getMousePos(W1B2_Black_Canvas, e);
      if (m.x < cX) {
        if (m.y < cY) pos = 180 + Math.floor(Math.atan((m.y - cY) / (cX - m.x)) * (180 / Math.PI));
        else pos = 180 + -Math.floor(Math.atan((m.y - cY) / (m.x - cX)) * (180 / Math.PI));
      } else {
        if (m.y < cY) pos = - Math.floor(Math.atan((cY - m.y) / (cX - m.x)) * (180 / Math.PI)) ;
        else pos = 360 + Math.floor(Math.atan((cY - m.y) / (m.x - cX)) * (180 / Math.PI));
      }

      // print the result
      ctx4.clearRect(0, 0, W1B2_Black_Canvas.width, W1B2_Black_Canvas.height);
    
      // prevent pictures from going out of canvas
      if (m.y >= maxY)
        m.y = maxY;
      else if (m.y < minY)
        m.y = 0;

      ctx4.drawImage(two_black_2, 0, 0+m.y, 100, 100);
      ctx4.drawImage(three_black_3, 0, maxY, 100, 100);
    }, false); // end of W1B2_Black_Canvas.addEventListener("mousemove", function(e){...});

    /*
    * W1W2_Black
    */

    // Get a "handle" on the canvas to work with
    W1W2_Black_Canvas = document.getElementById("W1W2_Black");
      
    // Get a "context"
    ctx5= W1W2_Black_Canvas.getContext("2d");

    // draw the initial image
    ctx5.drawImage(two_black_2, 0, 0, 100, 100);
    ctx5.drawImage(two_black_3, 0, maxY, 100, 100);
    ctx5.globalAlpha = 1.0;

    // Get the position of the mouse relative to the canvas
    function getMousePos(canvasDom, mouseEvent) {
      var rect = canvasDom.getBoundingClientRect();
      return {
        x: mouseEvent.clientX - rect.left,
        y: mouseEvent.clientY - rect.top
      };
    }

    // add mouse move listener to this canvas
    W1W2_Black_Canvas.addEventListener("mousemove", function(e) {
      var m = getMousePos(W1W2_Black_Canvas, e);
      if (m.x < cX) {
        if (m.y < cY) pos = 180 + Math.floor(Math.atan((m.y - cY) / (cX - m.x)) * (180 / Math.PI));
        else pos = 180 + -Math.floor(Math.atan((m.y - cY) / (m.x - cX)) * (180 / Math.PI));
      } else {
        if (m.y < cY) pos = - Math.floor(Math.atan((cY - m.y) / (cX - m.x)) * (180 / Math.PI)) ;
        else pos = 360 + Math.floor(Math.atan((cY - m.y) / (m.x - cX)) * (180 / Math.PI));
      }

      // print the result
      ctx5.clearRect(0, 0, W1W2_Black_Canvas.width, W1W2_Black_Canvas.height);
    
      // prevent pictures from going out of canvas
      if (m.y >= maxY)
        m.y = maxY;
      else if (m.y < minY)
        m.y = 0;

      ctx5.drawImage(two_black_2, 0, 0+m.y, 100, 100);
      ctx5.drawImage(two_black_3, 0, maxY, 100, 100);
    }, false); // end of W1W2_Black_Canvas.addEventListener("mousemove", function(e){...});

    /*
    * B1B2_White
    */

    // Get a "handle" on the canvas to work with
    B1B2_White_Canvas = document.getElementById("B1B2_White");
      
    // Get a "context"
    ctx6= B1B2_White_Canvas.getContext("2d");

    // draw the initial image
    ctx6.drawImage(three_black_4, 0, 0, 100, 100);
    ctx6.drawImage(three_black_4, 0, maxY, 100, 100);
    ctx6.globalAlpha = 1.0;

    // Get the position of the mouse relative to the canvas
    function getMousePos(canvasDom, mouseEvent) {
      var rect = canvasDom.getBoundingClientRect();
      return {
        x: mouseEvent.clientX - rect.left,
        y: mouseEvent.clientY - rect.top
      };
    }

    // add mouse move listener to this canvas
    B1B2_White_Canvas.addEventListener("mousemove", function(e) {
      var m = getMousePos(B1B2_White_Canvas, e);
      if (m.x < cX) {
        if (m.y < cY) pos = 180 + Math.floor(Math.atan((m.y - cY) / (cX - m.x)) * (180 / Math.PI));
        else pos = 180 + -Math.floor(Math.atan((m.y - cY) / (m.x - cX)) * (180 / Math.PI));
      } else {
        if (m.y < cY) pos = - Math.floor(Math.atan((cY - m.y) / (cX - m.x)) * (180 / Math.PI)) ;
        else pos = 360 + Math.floor(Math.atan((cY - m.y) / (m.x - cX)) * (180 / Math.PI));
      }

      // print the result
      ctx6.clearRect(0, 0, B1B2_White_Canvas.width, B1B2_White_Canvas.height);
    
      // prevent pictures from going out of canvas
      if (m.y >= maxY)
        m.y = maxY;
      else if (m.y < minY)
        m.y = 0;

      ctx6.drawImage(three_black_4, 0, 0+m.y, 100, 100);
      ctx6.drawImage(three_black_4, 0, maxY, 100, 100);
    }, false); // end of B1B2_White_Canvas.addEventListener("mousemove", function(e){...});

    /*
    * B1W2_White
    */

    // Get a "handle" on the canvas to work with
    B1W2_White_Canvas = document.getElementById("B1W2_White");
      
    // Get a "context"
    ctx7= B1W2_White_Canvas.getContext("2d");

    // draw the initial image
    ctx7.drawImage(three_black_4, 0, 0, 100, 100);
    ctx7.drawImage(two_black_2, 0, maxY, 100, 100);
    ctx7.globalAlpha = 1.0;

    // Get the position of the mouse relative to the canvas
    function getMousePos(canvasDom, mouseEvent) {
      var rect = canvasDom.getBoundingClientRect();
      return {
        x: mouseEvent.clientX - rect.left,
        y: mouseEvent.clientY - rect.top
      };
    }

    // add mouse move listener to this canvas
    B1W2_White_Canvas.addEventListener("mousemove", function(e) {
      var m = getMousePos(B1W2_White_Canvas, e);
      if (m.x < cX) {
        if (m.y < cY) pos = 180 + Math.floor(Math.atan((m.y - cY) / (cX - m.x)) * (180 / Math.PI));
        else pos = 180 + -Math.floor(Math.atan((m.y - cY) / (m.x - cX)) * (180 / Math.PI));
      } else {
        if (m.y < cY) pos = - Math.floor(Math.atan((cY - m.y) / (cX - m.x)) * (180 / Math.PI)) ;
        else pos = 360 + Math.floor(Math.atan((cY - m.y) / (m.x - cX)) * (180 / Math.PI));
      }

      // print the result
      ctx7.clearRect(0, 0, B1W2_White_Canvas.width, B1W2_White_Canvas.height);
    
      // prevent pictures from going out of canvas
      if (m.y >= maxY)
        m.y = maxY;
      else if (m.y < minY)
        m.y = 0;

      ctx7.drawImage(three_black_4, 0, 0+m.y, 100, 100);
      ctx7.drawImage(two_black_2, 0, maxY, 100, 100);
    }, false); // end of B1W2_White_Canvas.addEventListener("mousemove", function(e){...});

    /*
    * W1B2_White
    */

    // Get a "handle" on the canvas to work with
    W1B2_White_Canvas = document.getElementById("W1B2_White");
      
    // Get a "context"
    ctx8= W1B2_White_Canvas.getContext("2d");

    // draw the initial image
    ctx8.drawImage(two_black_2, 0, 0, 100, 100);
    ctx8.drawImage(three_black_4, 0, maxY, 100, 100);
    ctx8.globalAlpha = 1.0;

    // Get the position of the mouse relative to the canvas
    function getMousePos(canvasDom, mouseEvent) {
      var rect = canvasDom.getBoundingClientRect();
      return {
        x: mouseEvent.clientX - rect.left,
        y: mouseEvent.clientY - rect.top
      };
    }

    // add mouse move listener to this canvas
    W1B2_White_Canvas.addEventListener("mousemove", function(e) {
      var m = getMousePos(W1B2_White_Canvas, e);
      if (m.x < cX) {
        if (m.y < cY) pos = 180 + Math.floor(Math.atan((m.y - cY) / (cX - m.x)) * (180 / Math.PI));
        else pos = 180 + -Math.floor(Math.atan((m.y - cY) / (m.x - cX)) * (180 / Math.PI));
      } else {
        if (m.y < cY) pos = - Math.floor(Math.atan((cY - m.y) / (cX - m.x)) * (180 / Math.PI)) ;
        else pos = 360 + Math.floor(Math.atan((cY - m.y) / (m.x - cX)) * (180 / Math.PI));
      }

      // print the result
      ctx8.clearRect(0, 0, W1B2_White_Canvas.width, W1B2_White_Canvas.height);
    
      // prevent pictures from going out of canvas
      if (m.y >= maxY)
        m.y = maxY;
      else if (m.y < minY)
        m.y = 0;

      ctx8.drawImage(two_black_2, 0, 0+m.y, 100, 100);
      ctx8.drawImage(three_black_4, 0, maxY, 100, 100);
    }, false); // end of W1B2_White_Canvas.addEventListener("mousemove", function(e){...});

    /*
    * W1W2_White
    */

    // Get a "handle" on the canvas to work with
    W1W2_White_Canvas = document.getElementById("W1W2_White");
      
    // Get a "context"
    ctx9= W1W2_White_Canvas.getContext("2d");

    // draw the initial image
    ctx9.drawImage(two_black_2, 0, 0, 100, 100);
    ctx9.drawImage(two_black_1, 0, maxY, 100, 100);
    ctx9.globalAlpha = 1.0;

    // Get the position of the mouse relative to the canvas
    function getMousePos(canvasDom, mouseEvent) {
      var rect = canvasDom.getBoundingClientRect();
      return {
        x: mouseEvent.clientX - rect.left,
        y: mouseEvent.clientY - rect.top
      };
    }

    // add mouse move listener to this canvas
    W1W2_White_Canvas.addEventListener("mousemove", function(e) {
      var m = getMousePos(W1W2_White_Canvas, e);
      if (m.x < cX) {
        if (m.y < cY) pos = 180 + Math.floor(Math.atan((m.y - cY) / (cX - m.x)) * (180 / Math.PI));
        else pos = 180 + -Math.floor(Math.atan((m.y - cY) / (m.x - cX)) * (180 / Math.PI));
      } else {
        if (m.y < cY) pos = - Math.floor(Math.atan((cY - m.y) / (cX - m.x)) * (180 / Math.PI)) ;
        else pos = 360 + Math.floor(Math.atan((cY - m.y) / (m.x - cX)) * (180 / Math.PI));
      }

      // print the result
      ctx9.clearRect(0, 0, W1W2_White_Canvas.width, W1W2_White_Canvas.height);
    
      // prevent pictures from going out of canvas
      if (m.y >= maxY)
        m.y = maxY;
      else if (m.y < minY)
        m.y = 0;

      ctx9.drawImage(two_black_2, 0, 0+m.y, 100, 100);
      ctx9.drawImage(two_black_1, 0, maxY, 100, 100);
    }, false); // end of W1W2_White_Canvas.addEventListener("mousemove", function(e){...});

  }; // end of window.addEventListener('load', function(){...})

  $(window).on("load", function() {
    tryToDrawRecon();
    tryToDrawShares();
    document.getElementById("loader").style.display = "none";
  });

</script>

{% include "footer.html" %}